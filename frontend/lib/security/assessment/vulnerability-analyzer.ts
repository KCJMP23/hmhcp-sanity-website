/**
 * Vulnerability Analysis and Assessment System
 * CVSS scoring and vulnerability prioritization
 */

import { logger } from '@/lib/logger'
import { Vulnerability, VulnerabilitySeverity } from './security-scanner'

export interface CVSSVector {
  // Base Metrics
  attackVector: 'NETWORK' | 'ADJACENT' | 'LOCAL' | 'PHYSICAL'
  attackComplexity: 'LOW' | 'HIGH'
  privilegesRequired: 'NONE' | 'LOW' | 'HIGH'
  userInteraction: 'NONE' | 'REQUIRED'
  scope: 'UNCHANGED' | 'CHANGED'
  confidentialityImpact: 'NONE' | 'LOW' | 'HIGH'
  integrityImpact: 'NONE' | 'LOW' | 'HIGH'
  availabilityImpact: 'NONE' | 'LOW' | 'HIGH'
  
  // Temporal Metrics (optional)
  exploitCodeMaturity?: 'NOT_DEFINED' | 'UNPROVEN' | 'PROOF_OF_CONCEPT' | 'FUNCTIONAL' | 'HIGH'
  remediationLevel?: 'NOT_DEFINED' | 'OFFICIAL_FIX' | 'TEMPORARY_FIX' | 'WORKAROUND' | 'UNAVAILABLE'
  reportConfidence?: 'NOT_DEFINED' | 'UNKNOWN' | 'REASONABLE' | 'CONFIRMED'
  
  // Environmental Metrics (optional) 
  confidentialityRequirement?: 'NOT_DEFINED' | 'LOW' | 'MEDIUM' | 'HIGH'
  integrityRequirement?: 'NOT_DEFINED' | 'LOW' | 'MEDIUM' | 'HIGH'
  availabilityRequirement?: 'NOT_DEFINED' | 'LOW' | 'MEDIUM' | 'HIGH'
}

export interface VulnerabilityAnalysis {
  vulnerability: Vulnerability
  cvssScore: number
  cvssVector: CVSSVector
  cvssString: string
  exploitabilityScore: number
  impactScore: number
  riskScore: number
  healthcareImpact: HealthcareImpact
  priorityScore: number
  remediationPriority: 'IMMEDIATE' | 'HIGH' | 'MEDIUM' | 'LOW'
  estimatedEffort: EffortEstimate
  relatedVulnerabilities: string[]
  attackChains: AttackChain[]
}

export interface HealthcareImpact {
  phiExposureRisk: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'NONE'
  hipaaViolation: boolean
  hitrustImpact: boolean
  patientSafetyRisk: boolean
  operationalImpact: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  reputationalImpact: 'SEVERE' | 'MAJOR' | 'MODERATE' | 'MINOR'
  financialImpact: {
    estimatedCost: number
    currency: string
    breakdown: {
      fines: number
      remediation: number
      downtime: number
      legalFees: number
      reputational: number
    }
  }
}

export interface EffortEstimate {
  hours: number
  complexity: 'LOW' | 'MEDIUM' | 'HIGH' | 'VERY_HIGH'
  requiredSkills: string[]
  dependencies: string[]
  testingRequired: boolean
  downtimeRequired: boolean
}

export interface AttackChain {
  id: string
  name: string
  description: string
  steps: AttackStep[]
  likelihood: 'VERY_HIGH' | 'HIGH' | 'MEDIUM' | 'LOW' | 'VERY_LOW'
  impact: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  mitreTechniques: string[]
}

export interface AttackStep {
  order: number
  technique: string
  description: string
  prerequisites: string[]
  indicators: string[]
  detection: string[]
}

export class VulnerabilityAnalyzer {
  private vulnerabilityDatabase: Map<string, VulnerabilityAnalysis> = new Map()
  private cveDatabase: Map<string, any> = new Map() // Would connect to NVD in production
  
  /**
   * Analyze a vulnerability and calculate scores
   */
  async analyzeVulnerability(vulnerability: Vulnerability): Promise<VulnerabilityAnalysis> {
    try {
      // Parse or generate CVSS vector
      const cvssVector = this.parseCVSSVector(vulnerability.cvssVector) || this.generateCVSSVector(vulnerability)
      
      // Calculate CVSS scores
      const baseScore = this.calculateCVSSBaseScore(cvssVector)
      const temporalScore = this.calculateCVSSTemporalScore(cvssVector, baseScore)
      const environmentalScore = this.calculateCVSSEnvironmentalScore(cvssVector, temporalScore)
      
      // Calculate additional scores
      const exploitabilityScore = this.calculateExploitabilityScore(cvssVector)
      const impactScore = this.calculateImpactScore(cvssVector)
      const riskScore = this.calculateRiskScore(vulnerability, baseScore)
      
      // Assess healthcare-specific impact
      const healthcareImpact = this.assessHealthcareImpact(vulnerability)
      
      // Calculate priority score
      const priorityScore = this.calculatePriorityScore(
        vulnerability,
        baseScore,
        healthcareImpact
      )
      
      // Determine remediation priority
      const remediationPriority = this.determineRemediationPriority(priorityScore)
      
      // Estimate remediation effort
      const estimatedEffort = this.estimateRemediationEffort(vulnerability)
      
      // Find related vulnerabilities
      const relatedVulnerabilities = await this.findRelatedVulnerabilities(vulnerability)
      
      // Identify potential attack chains
      const attackChains = this.identifyAttackChains(vulnerability)
      
      const analysis: VulnerabilityAnalysis = {
        vulnerability,
        cvssScore: environmentalScore || temporalScore || baseScore,
        cvssVector,
        cvssString: this.generateCVSSString(cvssVector),
        exploitabilityScore,
        impactScore,
        riskScore,
        healthcareImpact,
        priorityScore,
        remediationPriority,
        estimatedEffort,
        relatedVulnerabilities,
        attackChains
      }
      
      // Store analysis
      this.vulnerabilityDatabase.set(vulnerability.id, analysis)
      
      return analysis
      
    } catch (error) {
      logger.error('Vulnerability analysis failed:', { 
        vulnerabilityId: vulnerability.id,
        error: error instanceof Error ? error.message : 'Unknown error'
      })
      throw error
    }
  }
  
  /**
   * Parse CVSS vector string
   */
  private parseCVSSVector(vectorString?: string): CVSSVector | null {
    if (!vectorString) return null
    
    // Parse CVSS v3.1 vector string
    // Format: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    const parts = vectorString.split('/')
    const vector: Partial<CVSSVector> = {}
    
    for (const part of parts) {
      const [key, value] = part.split(':')
      switch (key) {
        case 'AV':
          vector.attackVector = this.mapAttackVector(value)
          break
        case 'AC':
          vector.attackComplexity = value as 'LOW' | 'HIGH'
          break
        case 'PR':
          vector.privilegesRequired = this.mapPrivileges(value)
          break
        case 'UI':
          vector.userInteraction = value === 'N' ? 'NONE' : 'REQUIRED'
          break
        case 'S':
          vector.scope = value === 'U' ? 'UNCHANGED' : 'CHANGED'
          break
        case 'C':
          vector.confidentialityImpact = this.mapImpact(value)
          break
        case 'I':
          vector.integrityImpact = this.mapImpact(value)
          break
        case 'A':
          vector.availabilityImpact = this.mapImpact(value)
          break
      }
    }
    
    return vector as CVSSVector
  }
  
  /**
   * Generate CVSS vector based on vulnerability characteristics
   */
  private generateCVSSVector(vulnerability: Vulnerability): CVSSVector {
    // Generate based on vulnerability type and severity
    let vector: CVSSVector = {
      attackVector: 'NETWORK',
      attackComplexity: 'LOW',
      privilegesRequired: 'NONE',
      userInteraction: 'NONE',
      scope: 'UNCHANGED',
      confidentialityImpact: 'NONE',
      integrityImpact: 'NONE',
      availabilityImpact: 'NONE'
    }
    
    // Adjust based on severity
    switch (vulnerability.severity) {
      case VulnerabilitySeverity.CRITICAL:
        vector.confidentialityImpact = 'HIGH'
        vector.integrityImpact = 'HIGH'
        vector.availabilityImpact = 'HIGH'
        break
      case VulnerabilitySeverity.HIGH:
        vector.confidentialityImpact = 'HIGH'
        vector.integrityImpact = 'HIGH'
        vector.availabilityImpact = 'LOW'
        break
      case VulnerabilitySeverity.MEDIUM:
        vector.confidentialityImpact = 'LOW'
        vector.integrityImpact = 'LOW'
        vector.availabilityImpact = 'LOW'
        vector.privilegesRequired = 'LOW'
        break
      case VulnerabilitySeverity.LOW:
        vector.confidentialityImpact = 'LOW'
        vector.privilegesRequired = 'HIGH'
        vector.userInteraction = 'REQUIRED'
        break
    }
    
    // Adjust based on CWE if available
    if (vulnerability.cwe) {
      if (vulnerability.cwe === 'CWE-89') { // SQL Injection
        vector.confidentialityImpact = 'HIGH'
        vector.integrityImpact = 'HIGH'
      } else if (vulnerability.cwe === 'CWE-79') { // XSS
        vector.userInteraction = 'REQUIRED'
        vector.scope = 'CHANGED'
      }
    }
    
    return vector
  }
  
  /**
   * Calculate CVSS base score
   */
  private calculateCVSSBaseScore(vector: CVSSVector): number {
    // CVSS v3.1 calculation
    const exploitability = this.calculateExploitabilitySubscore(vector)
    const impact = this.calculateImpactSubscore(vector)
    
    if (impact <= 0) return 0
    
    const baseScore = vector.scope === 'UNCHANGED'
      ? Math.min(impact + exploitability, 10)
      : Math.min(1.08 * (impact + exploitability), 10)
    
    return Math.round(baseScore * 10) / 10
  }
  
  /**
   * Calculate exploitability subscore
   */
  private calculateExploitabilitySubscore(vector: CVSSVector): number {
    const av = this.getAttackVectorScore(vector.attackVector)
    const ac = vector.attackComplexity === 'LOW' ? 0.77 : 0.44
    const pr = this.getPrivilegesScore(vector.privilegesRequired, vector.scope)
    const ui = vector.userInteraction === 'NONE' ? 0.85 : 0.62
    
    return 8.22 * av * ac * pr * ui
  }
  
  /**
   * Calculate impact subscore
   */
  private calculateImpactSubscore(vector: CVSSVector): number {
    const c = this.getImpactValue(vector.confidentialityImpact)
    const i = this.getImpactValue(vector.integrityImpact)
    const a = this.getImpactValue(vector.availabilityImpact)
    
    const iss = 1 - ((1 - c) * (1 - i) * (1 - a))
    
    if (vector.scope === 'UNCHANGED') {
      return 6.42 * iss
    } else {
      return 7.52 * (iss - 0.029) - 3.25 * Math.pow(iss - 0.02, 15)
    }
  }
  
  /**
   * Calculate temporal score
   */
  private calculateCVSSTemporalScore(vector: CVSSVector, baseScore: number): number {
    if (!vector.exploitCodeMaturity && !vector.remediationLevel && !vector.reportConfidence) {
      return baseScore
    }
    
    const e = this.getExploitCodeMaturityScore(vector.exploitCodeMaturity)
    const rl = this.getRemediationLevelScore(vector.remediationLevel)
    const rc = this.getReportConfidenceScore(vector.reportConfidence)
    
    return Math.round(baseScore * e * rl * rc * 10) / 10
  }
  
  /**
   * Calculate environmental score
   */
  private calculateCVSSEnvironmentalScore(vector: CVSSVector, temporalScore: number): number {
    if (!vector.confidentialityRequirement && !vector.integrityRequirement && !vector.availabilityRequirement) {
      return temporalScore
    }
    
    // Simplified environmental calculation
    const cr = this.getRequirementScore(vector.confidentialityRequirement)
    const ir = this.getRequirementScore(vector.integrityRequirement)
    const ar = this.getRequirementScore(vector.availabilityRequirement)
    
    const modifier = (cr + ir + ar) / 3
    return Math.round(temporalScore * modifier * 10) / 10
  }
  
  /**
   * Calculate exploitability score
   */
  private calculateExploitabilityScore(vector: CVSSVector): number {
    const base = this.calculateExploitabilitySubscore(vector)
    
    // Adjust for healthcare context
    let score = base
    
    // Network-accessible vulnerabilities are more critical in healthcare
    if (vector.attackVector === 'NETWORK') {
      score *= 1.2
    }
    
    // No user interaction required increases risk
    if (vector.userInteraction === 'NONE') {
      score *= 1.1
    }
    
    return Math.min(10, Math.round(score * 10) / 10)
  }
  
  /**
   * Calculate impact score
   */
  private calculateImpactScore(vector: CVSSVector): number {
    const base = this.calculateImpactSubscore(vector)
    
    // Healthcare-specific adjustments
    let score = base
    
    // Confidentiality breaches are critical in healthcare (PHI)
    if (vector.confidentialityImpact === 'HIGH') {
      score *= 1.3
    }
    
    // Integrity issues can affect patient safety
    if (vector.integrityImpact === 'HIGH') {
      score *= 1.2
    }
    
    return Math.min(10, Math.round(score * 10) / 10)
  }
  
  /**
   * Calculate overall risk score
   */
  private calculateRiskScore(vulnerability: Vulnerability, cvssScore: number): number {
    let riskScore = cvssScore
    
    // Adjust for exploit availability
    if (vulnerability.exploitAvailable) {
      riskScore *= 1.3
    }
    
    if (vulnerability.publicExploit) {
      riskScore *= 1.2
    }
    
    // Adjust for patch availability
    if (!vulnerability.patchAvailable) {
      riskScore *= 1.1
    }
    
    return Math.min(10, Math.round(riskScore * 10) / 10)
  }
  
  /**
   * Assess healthcare-specific impact
   */
  private assessHealthcareImpact(vulnerability: Vulnerability): HealthcareImpact {
    // Determine PHI exposure risk
    let phiExposureRisk: HealthcareImpact['phiExposureRisk'] = 'NONE'
    if (vulnerability.affectedComponent.includes('patient') || 
        vulnerability.affectedComponent.includes('medical') ||
        vulnerability.affectedComponent.includes('health')) {
      phiExposureRisk = vulnerability.severity === VulnerabilitySeverity.CRITICAL ? 'CRITICAL' :
                       vulnerability.severity === VulnerabilitySeverity.HIGH ? 'HIGH' :
                       vulnerability.severity === VulnerabilitySeverity.MEDIUM ? 'MEDIUM' : 'LOW'
    }
    
    // Check HIPAA violation potential
    const hipaaViolation = phiExposureRisk !== 'NONE' && phiExposureRisk !== 'LOW'
    
    // Check HITRUST impact
    const hitrustImpact = vulnerability.severity === VulnerabilitySeverity.CRITICAL ||
                         vulnerability.severity === VulnerabilitySeverity.HIGH
    
    // Assess patient safety risk
    const patientSafetyRisk = vulnerability.affectedComponent.includes('clinical') ||
                              vulnerability.affectedComponent.includes('medical') ||
                              vulnerability.title.includes('integrity')
    
    // Determine operational impact
    const operationalImpact = vulnerability.severity === VulnerabilitySeverity.CRITICAL ? 'CRITICAL' :
                              vulnerability.severity === VulnerabilitySeverity.HIGH ? 'HIGH' :
                              vulnerability.severity === VulnerabilitySeverity.MEDIUM ? 'MEDIUM' : 'LOW'
    
    // Assess reputational impact
    const reputationalImpact = phiExposureRisk === 'CRITICAL' ? 'SEVERE' :
                               phiExposureRisk === 'HIGH' ? 'MAJOR' :
                               phiExposureRisk === 'MEDIUM' ? 'MODERATE' : 'MINOR'
    
    // Estimate financial impact
    const financialImpact = this.estimateFinancialImpact(
      vulnerability,
      phiExposureRisk,
      hipaaViolation
    )
    
    return {
      phiExposureRisk,
      hipaaViolation,
      hitrustImpact,
      patientSafetyRisk,
      operationalImpact,
      reputationalImpact,
      financialImpact
    }
  }
  
  /**
   * Estimate financial impact of vulnerability
   */
  private estimateFinancialImpact(
    vulnerability: Vulnerability,
    phiExposureRisk: HealthcareImpact['phiExposureRisk'],
    hipaaViolation: boolean
  ): HealthcareImpact['financialImpact'] {
    let fines = 0
    let remediation = 0
    let downtime = 0
    let legalFees = 0
    let reputational = 0
    
    // HIPAA fines
    if (hipaaViolation) {
      if (phiExposureRisk === 'CRITICAL') {
        fines = 2000000 // Max annual penalty
      } else if (phiExposureRisk === 'HIGH') {
        fines = 1000000
      } else {
        fines = 250000
      }
    }
    
    // Remediation costs
    switch (vulnerability.severity) {
      case VulnerabilitySeverity.CRITICAL:
        remediation = 100000
        break
      case VulnerabilitySeverity.HIGH:
        remediation = 50000
        break
      case VulnerabilitySeverity.MEDIUM:
        remediation = 20000
        break
      default:
        remediation = 5000
    }
    
    // Downtime costs (healthcare systems)
    if (vulnerability.severity === VulnerabilitySeverity.CRITICAL) {
      downtime = 500000 // Per day for critical systems
    } else if (vulnerability.severity === VulnerabilitySeverity.HIGH) {
      downtime = 100000
    }
    
    // Legal fees for breach response
    if (hipaaViolation) {
      legalFees = 250000
    }
    
    // Reputational damage
    if (phiExposureRisk === 'CRITICAL' || phiExposureRisk === 'HIGH') {
      reputational = 1000000 // Lost business, patient trust
    }
    
    const estimatedCost = fines + remediation + downtime + legalFees + reputational
    
    return {
      estimatedCost,
      currency: 'USD',
      breakdown: {
        fines,
        remediation,
        downtime,
        legalFees,
        reputational
      }
    }
  }
  
  /**
   * Calculate priority score for remediation
   */
  private calculatePriorityScore(
    vulnerability: Vulnerability,
    cvssScore: number,
    healthcareImpact: HealthcareImpact
  ): number {
    let score = cvssScore * 10 // Base from CVSS
    
    // Healthcare impact multipliers
    if (healthcareImpact.phiExposureRisk === 'CRITICAL') score *= 2
    else if (healthcareImpact.phiExposureRisk === 'HIGH') score *= 1.5
    
    if (healthcareImpact.hipaaViolation) score *= 1.5
    if (healthcareImpact.patientSafetyRisk) score *= 1.8
    
    // Exploit availability
    if (vulnerability.exploitAvailable) score *= 1.3
    if (vulnerability.publicExploit) score *= 1.5
    
    // Patch availability (inverse - no patch = higher priority)
    if (!vulnerability.patchAvailable) score *= 1.4
    
    return Math.min(100, Math.round(score))
  }
  
  /**
   * Determine remediation priority
   */
  private determineRemediationPriority(priorityScore: number): VulnerabilityAnalysis['remediationPriority'] {
    if (priorityScore >= 90) return 'IMMEDIATE'
    if (priorityScore >= 70) return 'HIGH'
    if (priorityScore >= 40) return 'MEDIUM'
    return 'LOW'
  }
  
  /**
   * Estimate remediation effort
   */
  private estimateRemediationEffort(vulnerability: Vulnerability): EffortEstimate {
    let hours = 0
    let complexity: EffortEstimate['complexity'] = 'LOW'
    const requiredSkills: string[] = []
    const dependencies: string[] = []
    
    // Base effort on vulnerability type
    if (vulnerability.cwe === 'CWE-89') { // SQL Injection
      hours = 40
      complexity = 'HIGH'
      requiredSkills.push('Database Security', 'Application Security')
      dependencies.push('Code Review', 'Database Schema Analysis')
    } else if (vulnerability.cwe === 'CWE-79') { // XSS
      hours = 20
      complexity = 'MEDIUM'
      requiredSkills.push('Web Security', 'Frontend Development')
      dependencies.push('Input Validation Library')
    } else {
      // Default estimates
      switch (vulnerability.severity) {
        case VulnerabilitySeverity.CRITICAL:
          hours = 80
          complexity = 'VERY_HIGH'
          break
        case VulnerabilitySeverity.HIGH:
          hours = 40
          complexity = 'HIGH'
          break
        case VulnerabilitySeverity.MEDIUM:
          hours = 20
          complexity = 'MEDIUM'
          break
        default:
          hours = 8
          complexity = 'LOW'
      }
    }
    
    // Adjust for patch availability
    if (vulnerability.patchAvailable) {
      hours = Math.max(4, hours * 0.3) // Applying patch is quicker
      complexity = 'LOW'
    }
    
    const testingRequired = vulnerability.severity === VulnerabilitySeverity.CRITICAL ||
                           vulnerability.severity === VulnerabilitySeverity.HIGH
    
    const downtimeRequired = vulnerability.affectedComponent.includes('critical') ||
                             vulnerability.severity === VulnerabilitySeverity.CRITICAL
    
    return {
      hours,
      complexity,
      requiredSkills,
      dependencies,
      testingRequired,
      downtimeRequired
    }
  }
  
  /**
   * Find related vulnerabilities
   */
  private async findRelatedVulnerabilities(vulnerability: Vulnerability): Promise<string[]> {
    const related: string[] = []
    
    // Find by CWE
    if (vulnerability.cwe) {
      for (const [id, analysis] of this.vulnerabilityDatabase.entries()) {
        if (analysis.vulnerability.cwe === vulnerability.cwe && id !== vulnerability.id) {
          related.push(id)
        }
      }
    }
    
    // Find by affected component
    for (const [id, analysis] of this.vulnerabilityDatabase.entries()) {
      if (analysis.vulnerability.affectedComponent === vulnerability.affectedComponent && 
          id !== vulnerability.id) {
        related.push(id)
      }
    }
    
    return [...new Set(related)] // Remove duplicates
  }
  
  /**
   * Identify potential attack chains
   */
  private identifyAttackChains(vulnerability: Vulnerability): AttackChain[] {
    const chains: AttackChain[] = []
    
    // SQL Injection attack chain
    if (vulnerability.cwe === 'CWE-89') {
      chains.push({
        id: 'chain_sqli_data_breach',
        name: 'SQL Injection to Data Breach',
        description: 'Exploit SQL injection to access PHI data',
        steps: [
          {
            order: 1,
            technique: 'Initial Access',
            description: 'Identify vulnerable input parameter',
            prerequisites: ['Public facing application'],
            indicators: ['Unusual SQL queries', 'Database errors in responses'],
            detection: ['WAF alerts', 'Database audit logs']
          },
          {
            order: 2,
            technique: 'Exploitation',
            description: 'Execute SQL injection payload',
            prerequisites: ['Vulnerable parameter identified'],
            indicators: ['Abnormal database queries', 'Large data transfers'],
            detection: ['Database monitoring', 'Network traffic analysis']
          },
          {
            order: 3,
            technique: 'Data Exfiltration',
            description: 'Extract PHI records',
            prerequisites: ['Database access achieved'],
            indicators: ['Large outbound data transfer', 'Off-hours activity'],
            detection: ['DLP alerts', 'Network monitoring']
          }
        ],
        likelihood: 'HIGH',
        impact: 'CRITICAL',
        mitreTechniques: ['T1190', 'T1055', 'T1041']
      })
    }
    
    // XSS attack chain
    if (vulnerability.cwe === 'CWE-79') {
      chains.push({
        id: 'chain_xss_session_hijack',
        name: 'XSS to Session Hijacking',
        description: 'Use XSS to steal healthcare worker credentials',
        steps: [
          {
            order: 1,
            technique: 'Payload Delivery',
            description: 'Inject malicious script via vulnerable input',
            prerequisites: ['User interaction required'],
            indicators: ['Suspicious JavaScript in inputs'],
            detection: ['Content Security Policy violations']
          },
          {
            order: 2,
            technique: 'Credential Theft',
            description: 'Steal session cookies or credentials',
            prerequisites: ['Script execution in victim browser'],
            indicators: ['Unexpected external requests'],
            detection: ['CSP reports', 'Network monitoring']
          },
          {
            order: 3,
            technique: 'Account Takeover',
            description: 'Access healthcare systems with stolen credentials',
            prerequisites: ['Valid session/credentials obtained'],
            indicators: ['Login from unusual location', 'Abnormal access patterns'],
            detection: ['Authentication monitoring', 'Behavioral analysis']
          }
        ],
        likelihood: 'MEDIUM',
        impact: 'HIGH',
        mitreTechniques: ['T1189', 'T1539', 'T1078']
      })
    }
    
    return chains
  }
  
  /**
   * Generate CVSS string from vector
   */
  private generateCVSSString(vector: CVSSVector): string {
    const parts = [
      'CVSS:3.1',
      `AV:${this.getVectorAbbreviation('AV', vector.attackVector)}`,
      `AC:${vector.attackComplexity === 'LOW' ? 'L' : 'H'}`,
      `PR:${this.getVectorAbbreviation('PR', vector.privilegesRequired)}`,
      `UI:${vector.userInteraction === 'NONE' ? 'N' : 'R'}`,
      `S:${vector.scope === 'UNCHANGED' ? 'U' : 'C'}`,
      `C:${this.getVectorAbbreviation('C', vector.confidentialityImpact)}`,
      `I:${this.getVectorAbbreviation('I', vector.integrityImpact)}`,
      `A:${this.getVectorAbbreviation('A', vector.availabilityImpact)}`
    ]
    
    return parts.join('/')
  }
  
  // Helper methods for CVSS calculations
  private mapAttackVector(value: string): CVSSVector['attackVector'] {
    switch (value) {
      case 'N': return 'NETWORK'
      case 'A': return 'ADJACENT'
      case 'L': return 'LOCAL'
      case 'P': return 'PHYSICAL'
      default: return 'NETWORK'
    }
  }
  
  private mapPrivileges(value: string): CVSSVector['privilegesRequired'] {
    switch (value) {
      case 'N': return 'NONE'
      case 'L': return 'LOW'
      case 'H': return 'HIGH'
      default: return 'NONE'
    }
  }
  
  private mapImpact(value: string): 'NONE' | 'LOW' | 'HIGH' {
    switch (value) {
      case 'N': return 'NONE'
      case 'L': return 'LOW'
      case 'H': return 'HIGH'
      default: return 'NONE'
    }
  }
  
  private getAttackVectorScore(av: CVSSVector['attackVector']): number {
    switch (av) {
      case 'NETWORK': return 0.85
      case 'ADJACENT': return 0.62
      case 'LOCAL': return 0.55
      case 'PHYSICAL': return 0.2
    }
  }
  
  private getPrivilegesScore(pr: CVSSVector['privilegesRequired'], scope: CVSSVector['scope']): number {
    if (scope === 'UNCHANGED') {
      switch (pr) {
        case 'NONE': return 0.85
        case 'LOW': return 0.62
        case 'HIGH': return 0.27
      }
    } else {
      switch (pr) {
        case 'NONE': return 0.85
        case 'LOW': return 0.68
        case 'HIGH': return 0.5
      }
    }
  }
  
  private getImpactValue(impact: 'NONE' | 'LOW' | 'HIGH'): number {
    switch (impact) {
      case 'NONE': return 0
      case 'LOW': return 0.22
      case 'HIGH': return 0.56
    }
  }
  
  private getExploitCodeMaturityScore(ecm?: CVSSVector['exploitCodeMaturity']): number {
    switch (ecm) {
      case 'HIGH': return 1
      case 'FUNCTIONAL': return 0.97
      case 'PROOF_OF_CONCEPT': return 0.94
      case 'UNPROVEN': return 0.91
      default: return 1
    }
  }
  
  private getRemediationLevelScore(rl?: CVSSVector['remediationLevel']): number {
    switch (rl) {
      case 'UNAVAILABLE': return 1
      case 'WORKAROUND': return 0.97
      case 'TEMPORARY_FIX': return 0.96
      case 'OFFICIAL_FIX': return 0.95
      default: return 1
    }
  }
  
  private getReportConfidenceScore(rc?: CVSSVector['reportConfidence']): number {
    switch (rc) {
      case 'CONFIRMED': return 1
      case 'REASONABLE': return 0.96
      case 'UNKNOWN': return 0.92
      default: return 1
    }
  }
  
  private getRequirementScore(req?: CVSSVector['confidentialityRequirement']): number {
    switch (req) {
      case 'HIGH': return 1.5
      case 'MEDIUM': return 1
      case 'LOW': return 0.5
      default: return 1
    }
  }
  
  private getVectorAbbreviation(type: string, value: any): string {
    switch (type) {
      case 'AV':
        switch (value) {
          case 'NETWORK': return 'N'
          case 'ADJACENT': return 'A'
          case 'LOCAL': return 'L'
          case 'PHYSICAL': return 'P'
        }
        break
      case 'PR':
        switch (value) {
          case 'NONE': return 'N'
          case 'LOW': return 'L'
          case 'HIGH': return 'H'
        }
        break
      case 'C':
      case 'I':
      case 'A':
        switch (value) {
          case 'NONE': return 'N'
          case 'LOW': return 'L'
          case 'HIGH': return 'H'
        }
        break
    }
    return 'N'
  }
  
  /**
   * Get vulnerability analysis by ID
   */
  getAnalysis(vulnerabilityId: string): VulnerabilityAnalysis | undefined {
    return this.vulnerabilityDatabase.get(vulnerabilityId)
  }
  
  /**
   * Get all analyses
   */
  getAllAnalyses(): VulnerabilityAnalysis[] {
    return Array.from(this.vulnerabilityDatabase.values())
  }
  
  /**
   * Get high priority vulnerabilities
   */
  getHighPriorityVulnerabilities(): VulnerabilityAnalysis[] {
    return Array.from(this.vulnerabilityDatabase.values())
      .filter(analysis => 
        analysis.remediationPriority === 'IMMEDIATE' || 
        analysis.remediationPriority === 'HIGH'
      )
      .sort((a, b) => b.priorityScore - a.priorityScore)
  }
}

// Export singleton instance
export const vulnerabilityAnalyzer = new VulnerabilityAnalyzer()